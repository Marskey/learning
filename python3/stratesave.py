
base64CharsetOfKey = "ZYXWVUTSRQPONMLKJIHGFEDCBA$abcdefghijklmnopqrstuvwxyz#9876501234"
base64CharsetOfLic = "ZYXWVUTSRQPONMLKJIHGFEDCBA\tabcdefghijklmnopqrstuvwxyz 9876501234"

privateKey=[
0x00,0x00,0x00,0x00,0x96,0x30,0x07,0x77,0x2C,0x61,0x0E,0xEE,0xBA,0x51,0x09,0x99,
0x19,0xC4,0x6D,0x07,0x8F,0xF4,0x6A,0x70,0x35,0xA5,0x63,0xE9,0xA3,0x95,0x64,0x9E,
0x32,0x88,0xDB,0x0E,0xA4,0xB8,0xDC,0x79,0x1E,0xE9,0xD5,0xE0,0x88,0xD9,0xD2,0x97,
0x2B,0x4C,0xB6,0x09,0xBD,0x7C,0xB1,0x7E,0x07,0x2D,0xB8,0xE7,0x91,0x1D,0xBF,0x90,
0x64,0x10,0xB7,0x1D,0xF2,0x20,0xB0,0x6A,0x48,0x71,0xB9,0xF3,0xDE,0x41,0xBE,0x84,
0x7D,0xD4,0xDA,0x1A,0xEB,0xE4,0xDD,0x6D,0x51,0xB5,0xD4,0xF4,0xC7,0x85,0xD3,0x83,
0x56,0x98,0x6C,0x13,0xC0,0xA8,0x6B,0x64,0x7A,0xF9,0x62,0xFD,0xEC,0xC9,0x65,0x8A,
0x4F,0x5C,0x01,0x14,0xD9,0x6C,0x06,0x63,0x63,0x3D,0x0F,0xFA,0xF5,0x0D,0x08,0x8D,
0xC8,0x20,0x6E,0x3B,0x5E,0x10,0x69,0x4C,0xE4,0x41,0x60,0xD5,0x72,0x71,0x67,0xA2,
0xD1,0xE4,0x03,0x3C,0x47,0xD4,0x04,0x4B,0xFD,0x85,0x0D,0xD2,0x6B,0xB5,0x0A,0xA5,
0xFA,0xA8,0xB5,0x35,0x6C,0x98,0xB2,0x42,0xD6,0xC9,0xBB,0xDB,0x40,0xF9,0xBC,0xAC,
0xE3,0x6C,0xD8,0x32,0x75,0x5C,0xDF,0x45,0xCF,0x0D,0xD6,0xDC,0x59,0x3D,0xD1,0xAB,
0xAC,0x30,0xD9,0x26,0x3A,0x00,0xDE,0x51,0x80,0x51,0xD7,0xC8,0x16,0x61,0xD0,0xBF,
0xB5,0xF4,0xB4,0x21,0x23,0xC4,0xB3,0x56,0x99,0x95,0xBA,0xCF,0x0F,0xA5,0xBD,0xB8,
0x9E,0xB8,0x02,0x28,0x08,0x88,0x05,0x5F,0xB2,0xD9,0x0C,0xC6,0x24,0xE9,0x0B,0xB1,
0x87,0x7C,0x6F,0x2F,0x11,0x4C,0x68,0x58,0xAB,0x1D,0x61,0xC1,0x3D,0x2D,0x66,0xB6,
0x90,0x41,0xDC,0x76,0x06,0x71,0xDB,0x01,0xBC,0x20,0xD2,0x98,0x2A,0x10,0xD5,0xEF,
0x89,0x85,0xB1,0x71,0x1F,0xB5,0xB6,0x06,0xA5,0xE4,0xBF,0x9F,0x33,0xD4,0xB8,0xE8,
0xA2,0xC9,0x07,0x78,0x34,0xF9,0x00,0x0F,0x8E,0xA8,0x09,0x96,0x18,0x98,0x0E,0xE1,
0xBB,0x0D,0x6A,0x7F,0x2D,0x3D,0x6D,0x08,0x97,0x6C,0x64,0x91,0x01,0x5C,0x63,0xE6,
0xF4,0x51,0x6B,0x6B,0x62,0x61,0x6C,0x1C,0xD8,0x30,0x65,0x85,0x4E,0x00,0x62,0xF2,
0xED,0x95,0x06,0x6C,0x7B,0xA5,0x01,0x1B,0xC1,0xF4,0x08,0x82,0x57,0xC4,0x0F,0xF5,
0xC6,0xD9,0xB0,0x65,0x50,0xE9,0xB7,0x12,0xEA,0xB8,0xBE,0x8B,0x7C,0x88,0xB9,0xFC,
0xDF,0x1D,0xDD,0x62,0x49,0x2D,0xDA,0x15,0xF3,0x7C,0xD3,0x8C,0x65,0x4C,0xD4,0xFB,
0x58,0x61,0xB2,0x4D,0xCE,0x51,0xB5,0x3A,0x74,0x00,0xBC,0xA3,0xE2,0x30,0xBB,0xD4,
0x41,0xA5,0xDF,0x4A,0xD7,0x95,0xD8,0x3D,0x6D,0xC4,0xD1,0xA4,0xFB,0xF4,0xD6,0xD3,
0x6A,0xE9,0x69,0x43,0xFC,0xD9,0x6E,0x34,0x46,0x88,0x67,0xAD,0xD0,0xB8,0x60,0xDA,
0x73,0x2D,0x04,0x44,0xE5,0x1D,0x03,0x33,0x5F,0x4C,0x0A,0xAA,0xC9,0x7C,0x0D,0xDD,
0x3C,0x71,0x05,0x50,0xAA,0x41,0x02,0x27,0x10,0x10,0x0B,0xBE,0x86,0x20,0x0C,0xC9,
0x25,0xB5,0x68,0x57,0xB3,0x85,0x6F,0x20,0x09,0xD4,0x66,0xB9,0x9F,0xE4,0x61,0xCE,
0x0E,0xF9,0xDE,0x5E,0x98,0xC9,0xD9,0x29,0x22,0x98,0xD0,0xB0,0xB4,0xA8,0xD7,0xC7,
0x17,0x3D,0xB3,0x59,0x81,0x0D,0xB4,0x2E,0x3B,0x5C,0xBD,0xB7,0xAD,0x6C,0xBA,0xC0,
0x20,0x83,0xB8,0xED,0xB6,0xB3,0xBF,0x9A,0x0C,0xE2,0xB6,0x03,0x9A,0xD2,0xB1,0x74,
0x39,0x47,0xD5,0xEA,0xAF,0x77,0xD2,0x9D,0x15,0x26,0xDB,0x04,0x83,0x16,0xDC,0x73,
0x12,0x0B,0x63,0xE3,0x84,0x3B,0x64,0x94,0x3E,0x6A,0x6D,0x0D,0xA8,0x5A,0x6A,0x7A,
0x0B,0xCF,0x0E,0xE4,0x9D,0xFF,0x09,0x93,0x27,0xAE,0x00,0x0A,0xB1,0x9E,0x07,0x7D,
0x44,0x93,0x0F,0xF0,0xD2,0xA3,0x08,0x87,0x68,0xF2,0x01,0x1E,0xFE,0xC2,0x06,0x69,
0x5D,0x57,0x62,0xF7,0xCB,0x67,0x65,0x80,0x71,0x36,0x6C,0x19,0xE7,0x06,0x6B,0x6E,
0x76,0x1B,0xD4,0xFE,0xE0,0x2B,0xD3,0x89,0x5A,0x7A,0xDA,0x10,0xCC,0x4A,0xDD,0x67,
0x6F,0xDF,0xB9,0xF9,0xF9,0xEF,0xBE,0x8E,0x43,0xBE,0xB7,0x17,0xD5,0x8E,0xB0,0x60,
0xE8,0xA3,0xD6,0xD6,0x7E,0x93,0xD1,0xA1,0xC4,0xC2,0xD8,0x38,0x52,0xF2,0xDF,0x4F,
0xF1,0x67,0xBB,0xD1,0x67,0x57,0xBC,0xA6,0xDD,0x06,0xB5,0x3F,0x4B,0x36,0xB2,0x48,
0xDA,0x2B,0x0D,0xD8,0x4C,0x1B,0x0A,0xAF,0xF6,0x4A,0x03,0x36,0x60,0x7A,0x04,0x41,
0xC3,0xEF,0x60,0xDF,0x55,0xDF,0x67,0xA8,0xEF,0x8E,0x6E,0x31,0x79,0xBE,0x69,0x46,
0x8C,0xB3,0x61,0xCB,0x1A,0x83,0x66,0xBC,0xA0,0xD2,0x6F,0x25,0x36,0xE2,0x68,0x52,
0x95,0x77,0x0C,0xCC,0x03,0x47,0x0B,0xBB,0xB9,0x16,0x02,0x22,0x2F,0x26,0x05,0x55,
0xBE,0x3B,0xBA,0xC5,0x28,0x0B,0xBD,0xB2,0x92,0x5A,0xB4,0x2B,0x04,0x6A,0xB3,0x5C,
0xA7,0xFF,0xD7,0xC2,0x31,0xCF,0xD0,0xB5,0x8B,0x9E,0xD9,0x2C,0x1D,0xAE,0xDE,0x5B,
0xB0,0xC2,0x64,0x9B,0x26,0xF2,0x63,0xEC,0x9C,0xA3,0x6A,0x75,0x0A,0x93,0x6D,0x02,
0xA9,0x06,0x09,0x9C,0x3F,0x36,0x0E,0xEB,0x85,0x67,0x07,0x72,0x13,0x57,0x00,0x05,
0x82,0x4A,0xBF,0x95,0x14,0x7A,0xB8,0xE2,0xAE,0x2B,0xB1,0x7B,0x38,0x1B,0xB6,0x0C,
0x9B,0x8E,0xD2,0x92,0x0D,0xBE,0xD5,0xE5,0xB7,0xEF,0xDC,0x7C,0x21,0xDF,0xDB,0x0B,
0xD4,0xD2,0xD3,0x86,0x42,0xE2,0xD4,0xF1,0xF8,0xB3,0xDD,0x68,0x6E,0x83,0xDA,0x1F,
0xCD,0x16,0xBE,0x81,0x5B,0x26,0xB9,0xF6,0xE1,0x77,0xB0,0x6F,0x77,0x47,0xB7,0x18,
0xE6,0x5A,0x08,0x88,0x70,0x6A,0x0F,0xFF,0xCA,0x3B,0x06,0x66,0x5C,0x0B,0x01,0x11,
0xFF,0x9E,0x65,0x8F,0x69,0xAE,0x62,0xF8,0xD3,0xFF,0x6B,0x61,0x45,0xCF,0x6C,0x16,
0x78,0xE2,0x0A,0xA0,0xEE,0xD2,0x0D,0xD7,0x54,0x83,0x04,0x4E,0xC2,0xB3,0x03,0x39,
0x61,0x26,0x67,0xA7,0xF7,0x16,0x60,0xD0,0x4D,0x47,0x69,0x49,0xDB,0x77,0x6E,0x3E,
0x4A,0x6A,0xD1,0xAE,0xDC,0x5A,0xD6,0xD9,0x66,0x0B,0xDF,0x40,0xF0,0x3B,0xD8,0x37,
0x53,0xAE,0xBC,0xA9,0xC5,0x9E,0xBB,0xDE,0x7F,0xCF,0xB2,0x47,0xE9,0xFF,0xB5,0x30,
0x1C,0xF2,0xBD,0xBD,0x8A,0xC2,0xBA,0xCA,0x30,0x93,0xB3,0x53,0xA6,0xA3,0xB4,0x24,
0x05,0x36,0xD0,0xBA,0x93,0x06,0xD7,0xCD,0x29,0x57,0xDE,0x54,0xBF,0x67,0xD9,0x23,
0x2E,0x7A,0x66,0xB3,0xB8,0x4A,0x61,0xC4,0x02,0x1B,0x68,0x5D,0x94,0x2B,0x6F,0x2A,
0x37,0xBE,0x0B,0xB4,0xA1,0x8E,0x0C,0xC3,0x1B,0xDF,0x05,0x5A,0x8D,0xEF,0x02,0x2D,
]

def get32ByteValOfPKey(idx):
    i = 0; val = 0
    while i < 4:
        val += privateKey[idx + i] << (i * 8)
        i += 1
    return val

def printAsHex(array):
    str=""
    for i,val in enumerate(array):
        if 0 == i%8:
            str += '\n'
        strf = "{0:02X}[{0:3}]\t".format(val)
        str+=strf
    print(str)

class Base64(object):
    charset = ""
    def __init__(self, charset):
        self.charset = charset

    def _TXTto8bitNum_(self, text):
        nums = []
        for t in text:
            for i, v in enumerate(self.charset):
                if t == v:
                    nums.append(i)
        return nums

    def _NumtoText_(self, text):
        texts = "" 
        for t in text:
            if t >= 0 and t < len(self.charset):
                texts += self.charset[t]
        return texts

    def encode(self, text):
        chipertxt = []
        numTxt = self._TXTto8bitNum_(text)
        remain = len(numTxt) % 4
        if remain != 0:
            numTxt += [0]*(4 - remain)

        i = 0
        while i < len(numTxt):
            high = numTxt[i] << 0x2
            low = numTxt[i+1] & 0x30
            low = low >> 0x4
            chipertxt.append(high|low)
            #--------------------------
            high = numTxt[i+1] & 0xF
            high = high << 0x4
            low = numTxt[i+2] & 0x3C
            low = low >> 0x2
            chipertxt.append(high|low)
            #--------------------------
            high = numTxt[i+2] & 0x3
            high = high << 0x6
            low = numTxt[i+3] & 0x3F
            chipertxt.append(high|low)
            i += 4
        return chipertxt

    def decode(self, chiperTxt):
        nums = []
        i = 0
        while i < len(chiperTxt):
            a = chiperTxt[i]
            a = a >> 2
            nums.append(a)

            if (i + 1 >= len(chiperTxt)):
                break

            a = chiperTxt[i]
            a = a & 0x3
            a = a << 0x4
            b = chiperTxt[i+1]
            b = b & 0xF0
            b = b >> 4
            a = a | b
            nums.append(a)

            if (i + 2 >= len(chiperTxt)):
                break

            b = chiperTxt[i+1]
            b = b & 0xF
            b = b << 2
            c = chiperTxt[i+2]
            c = c & 0xC0
            c = c >> 6
            b = b | c
            nums.append(b)

            c = chiperTxt[i+2]
            c = c & 0x3F
            nums.append(c)
            i += 3
        return self._NumtoText_(nums)

def makeToECKeys(chipTxt):
    i = 0; j = 0
    h = len(chipTxt) // 2
    ECKeys = []
    while i < len(chipTxt):
        if j >= h:
            j = 0

        val = chipTxt[j] & 0xFF
        val2 = chipTxt[h+j] & 0xFF

        if i < h:
            val  *= 0x07
            val  &= 0xFF
            val2 *= 0xFFFFFFF8
            val2 &= 0xFF
        else:
            val  *= 0xFFFFFFF3
            val  &= 0xFF
            val2 *= 0x0F
            val2 &= 0xFF

        val += val2
        val //= 0x01
        val &= 0xFF
        ECKeys.append(val)
        i += 1; j += 1
    return ECKeys

uneckeysMap=dict()
def makeUnECKeyMap():
    i = 0; j = 0
    for i in range(0, 0xFF):
        for j in range(0, 0xFF):
            nums = [i,j]
            eckeys = makeToECKeys(nums)
            uneckeysMap[str(eckeys)] = nums
            j+=1
        i+=1

def makeToUnECKeys(eckeys):
    i = 0; j = 0
    h = len(eckeys) // 2
    plainNums = [0]*len(eckeys)
    while i < len(eckeys):
        if j >= h:
            j = 0
        val = [eckeys[j] & 0xFF, eckeys[h+j] & 0xFF]
        nums = uneckeysMap[str(val)]
        plainNums[j] = nums[0]
        plainNums[h+j] = nums[1]
        i += 1; j += 1
    return plainNums

def calSign(chiperTxt):
# add 1 to 38 to byte 8
    i = 0; sign = 0
    while i < len(chiperTxt) - 4:
        sign += chiperTxt[i] << (i*8)%32
        sign &= 0xffffffff
        i += 1

    i = 0
    while i < len(chiperTxt) - 4:
        a = sign >> 8
        b = (sign ^ chiperTxt[i]) & 0xFF
        c = get32ByteValOfPKey(b*4)
        sign = a ^ c
        i += 1
    #print("sign:", hex(sign))
    return sign

def deCodeKey(key):
    base64 = Base64(base64CharsetOfKey)
    chiperTxt = base64.encode(key.lstrip('1'))
    #printAsHex(chiperTxt)
    #print("rsp+34: 0x{0:0X}".format(len(chiperTxt)))

# change chiperTxt to ECKeys:
    chiperTxt = makeToECKeys(chiperTxt)
    #printAsHex(chiperTxt)

# get 4 front eckey as sign
    i = 0; sign = 0
    while i < 4:
        sign |= chiperTxt[i] << i*8
        i += 1
    #print("sign:",hex(sign))

# move forward 4
    i = 0
    while i < len(chiperTxt) - 4:
        chiperTxt[i] = chiperTxt[i+4]
        i += 1
    #printAsHex(chiperTxt)

    # chiperTxt = chiperTxt[:38]
    sign2 = calSign(chiperTxt)
    if (sign != sign2):
        print("decode failed")

    base64 = Base64(base64CharsetOfLic)
    ret = base64.decode(chiperTxt)

    if ret == 'ITK\t30 days\tTrial\tTr 7 4 19\tNT\tSTSIT\t70a3\tZZZZZZZZZZZZZZ':
        print("decode ok")

    print(ret)
    #rets = ret.split('\t')

def encodeLic(lic):
    makeUnECKeyMap()
    base64 = Base64(base64CharsetOfLic)
    lic = base64.encode(lic)
    sign = calSign(lic)

    i = 3
    while i >= 0:
        val = sign >> i * 8
        val &= 0xFF
        lic.insert(0, val)
        i -= 1
    plainNums = makeToUnECKeys(lic)
    #print(plainNums)

    base64 = Base64(base64CharsetOfKey)
    text = base64.decode(plainNums)
    text = "1" + text
    txt = ""
    i = 0
    for i in range(0, len(text)):
        txt += text[i]
        if (i+1) % 5 == 0:
            txt += '-'
        i += 1
    print(txt)
    #deCodeKey("1BhLj-2my24-mDyrs-mkSj5-7#ecu-UQkW2-7OK$N-GIv9e-UrQWg-ixTRS-1FsuL-ro")
    deCodeKey(txt)
         #'ITK\t30 days\tTrial\tTr 7 4 19\tNT\tSTSIT\t70a3\tZZZZZZZZZZZZZZ'
encodeLic('ILY\tBoard4All\tmon\tMonkey\tNT\tSTSSN STSIT\t9\tZZZZZZZZZZZZZZ')
